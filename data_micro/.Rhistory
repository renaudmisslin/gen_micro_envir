Histograms
Miscellaneous #15 Wordcloud
Miscellaneous
Animation #3 A cube in 3D
Animation
Maps #19 Map with leafletR
Maps
Interactive R graphics #92 Make Subplots with plotly
Interactive R graphics
Scatter Plot #44 Polynomial curve fitting
Scatter Plot
?rnd
rnorm(4)
as.integer(rnorm(3))
as.integer(rnorm(4))
results300616 <- read.csv("C:/Users/renaud/Desktop/marinebabe/results300616.csv", sep=";", stringsAsFactors=FALSE)
View(results300616)
result <- read.csv("C:/Users/renaud/Desktop/marinebabe/results300616.csv", sep=";", stringsAsFactors=FALSE)
remove(results300616)
result$Parmi.la.liste.ci.dessous..sélectionnez.trois.usages.que.vous.associez.prioritairement.au.sol..
str <- strsplit(',', result$Parmi.la.liste.ci.dessous..sélectionnez.trois.usages.que.vous.associez.prioritairement.au.sol..)
str(View)
View(str)
str <- strsplit(result$Parmi.la.liste.ci.dessous..sélectionnez.trois.usages.que.vous.associez.prioritairement.au.sol.., ',')
strsplit(result$Parmi.la.liste.ci.dessous..sélectionnez.trois.usages.que.vous.associez.prioritairement.au.sol.., ',')
str <- data.frame(strsplit(result$Parmi.la.liste.ci.dessous..sélectionnez.trois.usages.que.vous.associez.prioritairement.au.sol.., ','))
str[1,]
str(str[1,])
str[1,]
View(str[1,])
View(t(str[1,]))
t(str[i,])
t(str[1,])
table(t(str[1,]))
i <- 1
data.frame(table(t(str[i,])))
data.frame(table(t(str[2,])))
essai <- data.frame(table(t(str[2,])))
essai
essai[1]
essai[1,]
regexpr("Alimentation", essai[,1])
grep("Alimentation", essai[,1])
grep("Alimentaton", essai[,1])
grep("Alimentaton", essai[,1]) +1
length(grep("Alimentaton", essai[,1]))
library(rgeos)
library(raster)
?readOGR
library(rgdal)
?readOGR
kwaeng <- readOGR(dsn=dsn, layer="C:/Users/renaud/Dropbox/GEN_Bangok/admin/subdist160_recales")
kwaeng <- readOGR(dsn="C:/Users/renaud/Dropbox/GEN_Bangok/admin", layer="subdist160_recales")
croping <- raster("C:/Users/renaud/Desktop/these/modelisation/classif_envir/pop_croped.tif")
plot(croping)
?crop
plot(crop(kwaeng, croping))
croped <- crop(kwaeng, croping)
?writeOGR
writeOGR(croped, "C:/Users/renaud/Dropbox/GEN_Bangok/admin", "kwaeng_croped_shp", driver="ESRI Shapefile")
horaire_debut <- Sys.time()
library(rgdal)
dossier_general <- 'C:/Users/renaud/Desktop/these/modelisation/BD_50m/bkk/pop/version_indices'
nom_shp_admin <- 'kwaeng_pop_menages'
nom_shp_base <- 'occsol_30m_points_indices'
shp_base <- readOGR(dsn = dossier_general, layer = nom_shp_base)
shp_admin <- readOGR(dsn = dossier_general, layer = nom_shp_admin)
shp_base <- shp_base[!(shp_base$bkk_kwaeng == 0),]
data <- shp_base@data
fichier_final <- 'bkk_popest_30m'
pxl_size <- 900
shp_base <- shp_base[!(shp_base$bkk_kwaeng == 0),]
data <- shp_base@data
fichier_final <- 'bkk_popest_30m'
pxl_size <- 900
############################################################################################################################################
# Définition de la variable à expliquer (variable exogene)
#var_exo <- 'No_HH'
var_exo <- 'TOT_P'
var_endo <- 'bati_dense + bati_lache_moyen + b1_pca1011 + ndvi + ndbi_olico'
############################################################################################################################################
############################################################################################################################################
# Remplissage du tableau area_tot
############################################################################################################################################
area_tot <- data.frame(c(0))
names(area_tot) <- c('id')
lvls_cls <- levels(shp_base$Class_Name)
n_cls <- length(lvls_cls)
for (i in 1:length(lvls_cls)){
area_tot[1,i+1] <- 0
colnames(area_tot)[i+1] <- gsub('-', '_', lvls_cls[i])
}
n_cls
View(area_tot)
lvls_cls <- levels(shp_base$Class_Name)
n_cls <- length(lvls_cls)
for (i in 1:length(lvls_cls)){
area_tot[1,i+1] <- 0
colnames(area_tot)[i+1] <- gsub('-', '_', lvls_cls[i])
}
# Remplissage des surfaces d'occsol par unité admin
for (i in 1:(nrow(shp_admin))){
area_tot[i,1] <- shp_admin$id[i]
subset_kwaeng <- subset(data, bkk_kwaeng == shp_admin$id[i])
sum_b10_020214 <- 0
sum_b10_040115 <- 0
sum_b10_050215 <- 0
sum_b10_170114 <- 0
sum_b10_200115 <- 0
sum_ndvi <- 0
sum_ndbi_olico <- 0
# Calcul de la superficie des classes
for (j in 1:length(lvls_cls)){
cls <- lvls_cls[j]
col_cls <- gsub('-', '_', cls)
subset_cls <- subset(subset_kwaeng, Class_Name == cls)
# Calcul de la somme des indices pour les classes habitables seulement
if (cls == 'bati-dense' | cls == 'bati-lache'  | cls == 'bati-moyen' ){
sum_b10_020214 <- sum_b10_020214 + sum(subset_cls$b10_020214)
sum_b10_040115 <- sum_b10_040115 + sum(subset_cls$b10_040115)
sum_b10_050215 <- sum_b10_050215 + sum(subset_cls$b10_050215)
sum_b10_170114 <- sum_b10_170114 + sum(subset_cls$b10_170114)
sum_b10_200115 <- sum_b10_200115 + sum(subset_cls$b10_200115)
sum_ndvi <- sum_ndvi + sum(subset_cls$ndvi)
sum_ndbi_olico <- sum_ndbi_olico + sum(subset_cls$ndbi_olico)
}
if (nrow(subset_cls) > 0){
area <- pxl_size * nrow(subset_cls)
eval(parse(text=paste('area_tot$', col_cls, '[', i, '] <- ', area, sep='')))
} else {
area <- 0
eval(parse(text=paste('area_tot$', col_cls, '[', i, '] <- ', area, sep='')))
}
}
# Calcul de la somme de chaque indice
area_tot[i,n_cls+1] <- sum_b10_020214
area_tot[i,n_cls+2] <- sum_b10_040115
area_tot[i,n_cls+3] <- sum_b10_050215
area_tot[i,n_cls+4] <- sum_b10_170114
area_tot[i,n_cls+5] <- sum_b10_200115
area_tot[i,n_cls+6] <- sum_ndvi
area_tot[i,n_cls+7] <- sum_ndbi_olico
print(paste('District n°', i, ' sur ', nrow(shp_admin), sep=''))
}
colnames(area_tot)[n_cls+1] <- 'b10_020214'
colnames(area_tot)[n_cls+2] <- 'b10_040115'
colnames(area_tot)[n_cls+3] <- 'b10_050215'
colnames(area_tot)[n_cls+4] <- 'b10_170114'
colnames(area_tot)[n_cls+5] <- 'b10_200115'
colnames(area_tot)[n_cls+6] <- 'ndvi'
colnames(area_tot)[n_cls+7] <- 'ndbi_olico'
area_tot[1,1]
area_tot[1,2]
area_tot$bati_dense[1]
View(data)
View(shp_base)
View(shp_admin)
plot(shp_admin)
library(raster)
plot(raster(matrix(c=(0,1,0,1,0,1))))
plot(raster(matrix(0,1,0,1,0,1)))
.matrix
?matrix
as.matrix(c=(0,1,0,1)
plot(shp_admin, col="red")
plot(shp_admin[1])
area_tot <- merge(shp_admin@data, area_tot, by = 'id')
# Assemblage des classes de bâti lâches
area_tot$bati_lache_moyen <- area_tot$bati_lache + area_tot$bati_moyen
write.table(coef, fichier_coef, sep=";")
############################################################################################################################################
# Calcul de la régression
############################################################################################################################################
# Calcul de la régression sans intercept
reg <- lm(formula = No_HH ~ 0 + bati_dense + bati_lache_moyen + ndbi_olico, data = area_tot)
summary(reg)
reg <- lm(formula = No_HH ~ bati_dense + bati_lache_moyen + ndbi_olico, data = area_tot)
summary(reg)
?fuzzylm
coef <- coef(summary(reg))
fichier_coef <- paste(dossier_general, "/coef.txt", sep="")
write.table(coef, fichier_coef, sep=";")
coef <- read.table(fichier_coef, sep=";")
coef[5] <- row.names(coef[1])
# Estimation de la population de chaque entité administrative
area_tot["pop_est"] <- 0
for (i in 1:nrow(area_tot)){
area_tot$pop_est[i] <- 0
for (j in 1:nrow(coef)){
cls_en_cours <- coef[j,5]
area_cls <- eval(parse(text=paste('area_tot$',cls_en_cours,'[',i ,']',sep='')))
pop_cls <- area_cls * coef[j,1]
area_tot$pop_est[i] <- pop_cls  + area_tot$pop_est[i]
}
}
# Calcul du ratio
area_tot$ratio_correc <- 0
if (var_exo == 'TOT_P'){
area_tot$ratio_correc <- area_tot$pop_est / area_tot$TOT_P
} else {
area_tot$ratio_correc <- area_tot$pop_est / area_tot$No_HH
}
coef <- coef(summary(reg))
fichier_coef <- paste(dossier_general, "/coef.txt", sep="")
write.table(coef, fichier_coef, sep=";")
coef <- read.table(fichier_coef, sep=";")
coef[5] <- row.names(coef[1])
# Estimation de la population de chaque entité administrative
area_tot["pop_est"] <- 0
for (i in 1:nrow(area_tot)){
area_tot$pop_est[i] <- 0
for (j in 1:nrow(coef)){
cls_en_cours <- coef[j,5]
area_cls <- eval(parse(text=paste('area_tot$',cls_en_cours,'[',i ,']',sep='')))
pop_cls <- area_cls * coef[j,1]
area_tot$pop_est[i] <- pop_cls  + area_tot$pop_est[i]
}
}
# Calcul du ratio
area_tot$ratio_correc <- 0
if (var_exo == 'TOT_P'){
area_tot$ratio_correc <- area_tot$pop_est / area_tot$TOT_P
} else {
area_tot$ratio_correc <- area_tot$pop_est / area_tot$No_HH
}
cls_en_cours
reg <- lm(formula = No_HH ~ 0 + bati_dense + bati_lache_moyen + ndbi_olico, data = area_tot)
summary(reg)
############################################################################################################################################
# Calcul des coefficients de correction à appliquer à chaque entité admin
############################################################################################################################################
# Ecriture puis lecture du fichier contenant les coefficients (sinon on ne peut pas récupérer le nom des classes d'occsol associées)
coef <- coef(summary(reg))
fichier_coef <- paste(dossier_general, "/coef.txt", sep="")
write.table(coef, fichier_coef, sep=";")
coef <- read.table(fichier_coef, sep=";")
coef[5] <- row.names(coef[1])
# Estimation de la population de chaque entité administrative
area_tot["pop_est"] <- 0
for (i in 1:nrow(area_tot)){
area_tot$pop_est[i] <- 0
for (j in 1:nrow(coef)){
cls_en_cours <- coef[j,5]
area_cls <- eval(parse(text=paste('area_tot$',cls_en_cours,'[',i ,']',sep='')))
pop_cls <- area_cls * coef[j,1]
area_tot$pop_est[i] <- pop_cls  + area_tot$pop_est[i]
}
}
# Calcul du ratio
area_tot$ratio_correc <- 0
if (var_exo == 'TOT_P'){
area_tot$ratio_correc <- area_tot$pop_est / area_tot$TOT_P
} else {
area_tot$ratio_correc <- area_tot$pop_est / area_tot$No_HH
}
View(area_tot)
############################################################################################################################################
# Calcul du nombre d'habitants par pixel
############################################################################################################################################
shp_base$popco <- as.vector(NA)
# Récupération des coef (à part occsol)
noms_indices <- rownames(coef)[!grepl("bati", rownames(coef))]
coef_indices <- coef[noms_indices,]
coef_b10 <- 0
coef_b11 <- 0
coef_b1_pca1011 <- 0
coef_b2_pca1011 <- 0
coef_baem <- 0
coef_ndbi_oli <- 0
coef_ndvi <- 0
coef_ndbi_olico <- 0
for (i in 1:nrow(coef_indices)){
eval(parse(text=paste('coef_', coef_indices$V5[i] , ' <- ', coef_indices[i,1] , sep='')))
}
horaire_debut <- Sys.time()
for (i in 1:nrow(shp_base@data)){#nrow(shp_base)
cls_occsol <- gsub("-","_",shp_base@data$Class_Name[i])
if (cls_occsol == 'bati_dense' | cls_occsol == 'bati_lache'  | cls_occsol == 'bati_moyen'){
# Récupération des données associées au pixel
b10 <- shp_base@data$b10[i]
b11 <- shp_base@data$b11[i]
b1_pca1011 <- shp_base@data$b1_pca1011[i]
b2_pca1011 <- shp_base@data$b2_pca1011[i]
baem <- shp_base@data$baem[i]
ndbi_oli <- shp_base@data$ndbi_oli[i]
ndvi <- shp_base@data$ndvi[i]
ndbi_olico <- shp_base@data$ndbi_olico[i]
# Récupération du ratio du ward auquel appartient le patch
tbl <- which(shp_base@data$bkk_kwaeng[i] == area_tot$id)
ratio_correc <- area_tot$ratio_correc[tbl]
# Récupération du coefficient de la catégorie occsol en cours
if (cls_occsol == 'bati_lache'  | cls_occsol == 'bati_moyen' ){
cls_occsol <- 'bati_lache_moyen'
}
ligne_coef <- which(as.character(cls_occsol) == as.character(coef$V5))
coef_occsol <- coef[ligne_coef,1]
# Estimation de la population du patch
pop_patch_est <- coef_occsol*pxl_size + coef_b10*b10 + coef_b11*b11 + coef_b1_pca1011*b1_pca1011 + coef_b1_pca1011*b1_pca1011 + coef_baem*baem + coef_ndbi_oli*ndbi_oli + coef_ndvi*ndvi + coef_ndbi_olico*ndbi_olico
pop_patch_est <- pop_patch_est / ratio_correc
} else {
pop_patch_est <- 0
}
if (var_exo == 'TOT_P'){
shp_base@data$popest[i] <- pop_patch_est
}
else{
shp_base@data$menest[i] <- pop_patch_est
}
if (i%%50000 == 0){
print(i)
}
}
shp_admin$ratio_correc <- as.vector(NA)
# Couplage des wards
for (i in 1:nrow(shp_admin)){
tbl <- which(shp_admin$id[i] == area_tot$id)
shp_admin$ratio_correc[i] <- area_tot$ratio_correc[tbl]
}
library(RColorBrewer)
library(classInt)
# Variables à définir
nb_cls <- 6
# Définition de la palette de couleurs
pal_ratio  <-  rev(brewer.pal(n  =  nb_cls,  name  =  "RdBu"))
# Calcul des intervals des classes
ratio_cls_jenks <- classIntervals(var = shp_admin@data$ratio_correc, n = nb_cls, style = "jenks")
brks_ratio_cls_jenks <- ratio_cls_jenks$brks
shp_admin@data$ratio_jenks  <-  as.character(cut(shp_admin@data$ratio_correc,
breaks  =  brks_ratio_cls_jenks,
labels  =  pal_ratio,
include.lowest  =  TRUE,
right  =  FALSE))
vLegendBoxJ  <-  as.character(levels(cut(shp_admin@data$ratio_correc,
breaks  =  brks_ratio_cls_jenks,
include.lowest  =  TRUE,
right  =  FALSE)))
plot(shp_admin,
col  =  shp_admin@data$ratio_jenks,
border  =  "white")
legend("bottomright",
legend  =  vLegendBoxJ,
bty  =  "n",
fill  =  pal_ratio,
cex  =  0.6,
title  =  "Ratio nombre de ménages estimé / nombre de ménages réels")
title(main  =  "Ratio nombre de ménages estimé / nombre de ménages réels")
reg <- lm(formula = No_HH ~ 0 + bati_dense + bati_lache_moyen + ndbi_olico + ndvi, data = area_tot)
summary(reg)
sum(area_tot$TOT_P)
area_tot$ratio_pop_tot <- area_tot$TOT_P / sum(area_tot$TOT_P)
reg <- lm(formula = TOT_P ~ 0 + bati_dense + bati_lache_moyen + ndbi_olico + ratio_pop_tot, data = area_tot)
summary(reg)
reg <- lm(formula = TOT_P ~ 0 + bati_dense + bati_lache_moyen + ndbi_olico + surface, data = area_tot)
summary(reg)
area_tot$densite <- area_tot$TOT_P / area_tot$surface
reg <- lm(formula = TOT_P ~ 0 + bati_dense + bati_lache_moyen + ndbi_olico + densite, data = area_tot)
summary(reg)
reg <- lm(formula = TOT_P ~ 0 + bati_dense + bati_lache_moyen + ndbi_olico, data = area_tot)
summary(reg)
coef <- coef(summary(reg))
fichier_coef <- paste(dossier_general, "/coef.txt", sep="")
write.table(coef, fichier_coef, sep=";")
coef <- read.table(fichier_coef, sep=";")
coef[5] <- row.names(coef[1])
# Estimation de la population de chaque entité administrative
area_tot["pop_est"] <- 0
for (i in 1:nrow(area_tot)){
area_tot$pop_est[i] <- 0
for (j in 1:nrow(coef)){
cls_en_cours <- coef[j,5]
area_cls <- eval(parse(text=paste('area_tot$',cls_en_cours,'[',i ,']',sep='')))
pop_cls <- area_cls * coef[j,1]
area_tot$pop_est[i] <- pop_cls  + area_tot$pop_est[i]
}
}
# Calcul du ratio
area_tot$ratio_correc <- 0
if (var_exo == 'TOT_P'){
area_tot$ratio_correc <- area_tot$pop_est / area_tot$TOT_P
} else {
area_tot$ratio_correc <- area_tot$pop_est / area_tot$No_HH
}
shp_admin$ratio_correc <- as.vector(NA)
# Couplage des wards
for (i in 1:nrow(shp_admin)){
tbl <- which(shp_admin$id[i] == area_tot$id)
shp_admin$ratio_correc[i] <- area_tot$ratio_correc[tbl]
}
library(RColorBrewer)
library(classInt)
# Variables à définir
nb_cls <- 6
# Définition de la palette de couleurs
pal_ratio  <-  rev(brewer.pal(n  =  nb_cls,  name  =  "RdBu"))
# Calcul des intervals des classes
ratio_cls_jenks <- classIntervals(var = shp_admin@data$ratio_correc, n = nb_cls, style = "jenks")
brks_ratio_cls_jenks <- ratio_cls_jenks$brks
shp_admin@data$ratio_jenks  <-  as.character(cut(shp_admin@data$ratio_correc,
breaks  =  brks_ratio_cls_jenks,
labels  =  pal_ratio,
include.lowest  =  TRUE,
right  =  FALSE))
vLegendBoxJ  <-  as.character(levels(cut(shp_admin@data$ratio_correc,
breaks  =  brks_ratio_cls_jenks,
include.lowest  =  TRUE,
right  =  FALSE)))
plot(shp_admin,
col  =  shp_admin@data$ratio_jenks,
border  =  "white")
legend("bottomright",
legend  =  vLegendBoxJ,
bty  =  "n",
fill  =  pal_ratio,
cex  =  0.6,
title  =  "Ratio nombre de ménages estimé / nombre de ménages réels")
title(main  =  "Ratio nombre de ménages estimé / nombre de ménages réels")
summary(area_tot$ratio_correc)
plot(area_tot$ratio_correc, area_tot$bati_dense)
plot(area_tot$ratio_correc, area_tot$bati_dense, pch=20)
plot(area_tot$TOT_P, area_tot$bati_dense, pch=20)
plot(area_tot$TOT_P, area_tot$ndvi, pch=20)
plot(area_tot$TOT_P, area_tot$bati_lache_moyen, pch=20)
plot(area_tot$TOT_P, area_tot$ndbi_olico, pch=20)
reg <- lm(formula = TOT_P ~ 0 + bati_dense, data = area_tot)
summary(reg)
reg <- lm(formula = TOT_P ~ 0 + bati_dense + densite, data = area_tot)
summary(reg)
plot(area_tot$TOT_P, area_tot$densite, pch=20)
?lm
reg <- lm(formula = TOT_P ~ 0 + bati_dense + temp_moy, data = area_tot)
summary(reg)
reg <- lm(formula = TOT_P ~ 0 + bati_dense + bati_lache_moyen + temp_moy, data = area_tot)
summary(reg)
reg <- lm(formula = TOT_P ~ 0 + bati_dense + bati_lache_moyen + temp_moy + ndbi_olico, data = area_tot)
summary(reg)
baem
pop_patch_est
ratio_correc
732/357603
z
732 /357 603
732 /357603
6048 /2396940
409/199747
160*0.02
89*0.02
26141/38223
16266/29000
365*27
365*27
2800+1750
4550 * 4550
7*30
210*240
2.5*2.5
8*6
2370*2520
30*30*52000
16+16
42*50*50
105000*42
rsq(1600)
sqrt(1600)
library(foreign)
?read.dta
read.dta("C:\Users\renaud\Desktop\rp12indcvi5.dta")
read.dta("C:/Users/renaud/Desktop/rp12indcvi5.dta")
setwd("rp12indcvi5.dta")")
setwd("C:/Users/renaud/Desktop/")
df <- read.dta("rp12indcvi5.dta")
df <- read.dta("C:/Users/renaud/Desktop/rp12indcvi5.dta")
View(df)
?write.csv
write.table(df, file="rp12indcvi5")
write.table(df, file="rp12indcvi5.csv")
df <- read.dta("C:/Users/renaud/Desktop/rp12indcvi4.dta")
write.table(df, file="rp12indcvi4")
df <- read.dta("C:/Users/renaud/Desktop/rp12indcvi3.dta")
write.table(df, file="rp12indcvi3.csv")
df <- read.dta("C:/Users/renaud/Desktop/rp12indcvi2.dta")
write.table(df, file="rp12indcvi2.csv")
df <- read.dta("C:/Users/renaud/Desktop/rp12indcvi1.dta")
write.table(df, file="rp12indcvi1.csv")
setwd("C:/Users/renaud/Desktop/these/modelisation/micro_2")
library(raster)
pop <- raster("bkk_popest_30m.tif")
men <- raster("bkk_menest_30m.tif")
ndvi <- raster("ndvi.tif")
plot(pop)
plot(men, add=TRUE)
plot(ndvi, add=TRUE)
mask <- raster("/data_micro/distraster.tif")
mask <- raster("/data_micro/dist_raster.tif")
mask <- raster("data_micro/dist_raster.tif")
plot(mask, add=TRUE)
r_dist_raster <- mask
pop_crop <- crop(pop, r_dist_raster)
men_crop <- crop(men, r_dist_raster)
ndvi_crop <- crop(ndvi, r_dist_raster)
pop_croped <- crop(pop, r_dist_raster)
men_croped <- crop(men, r_dist_raster)
ndvi_croped <- crop(ndvi, r_dist_raster)
writeRaster(pop_croped, "pop_zone.tif", overwrite=TRUE, format='GTiff')
writeRaster(men_croped, "men_zone.tif", overwrite=TRUE, format='GTiff')
writeRaster(ndvi_croped, "ndvi_zone.tif", overwrite=TRUE, format='GTiff')
setwd("C:/Users/renaud/Desktop/these/modelisation/micro_2/data_micro")
writeRaster(pop_croped, "pop_zone.tif", overwrite=TRUE, format='GTiff')
writeRaster(men_croped, "men_zone.tif", overwrite=TRUE, format='GTiff')
writeRaster(ndvi_croped, "ndvi_zone.tif", overwrite=TRUE, format='GTiff')
plot(ndvi_croped)
plot(mask,add=TRUE)
plot(r_dist_raster,add=TRUE)
